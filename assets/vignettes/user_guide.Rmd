---
title: R/qtl2 user guide
output: rmarkdown::html_vignette
---

```{r knitr_opts, include=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4)
options(width=140)
```


[R/qtl2](http://kbroman.org/qtl2) (aka qtl2) is a reimplementation of the QTL analysis software
[R/qtl](https://rqtl.org), to better handle high-dimensional data
and complex cross designs.

We expect that basic analyses with R/qtl2 will generally be performed
in "batch" (for example, on a cluster) rather than interactively. And
so the software is split into three parts:
[qtl2geno](https://github.com/rqtl/qtl2geno) for genotype probability
calculations, [qtl2scan](https://github.com/rqtl/qtl2scan) for QTL
scans, and [qtl2plot](https://github.com/rqtl/qtl2plot) for data
visualization.
A further package, [qtl2convert](https://github.com/rqtl/qtl2convert),
contains functions for converting data among the R/qtl2,
[DOQTL](https://www.bioconductor.org/packages/release/bioc/html/DOQTL.html),
and [R/qtl](https://rqtl.org) formats, for example to convert genotype
probabilities produced by DOQTL to the format needed by qtl2scan, or
to convert qtl2scan results to the format produced by `scanone` in
R/qtl, so that they may be graphed with the R/qtl functions.


## Installation

R/qtl2 is not yet available on [CRAN](https://cran.r-project.org), but
it can be installed from a mini-CRAN at [rqtl.org](https://rqtl.org).

    install.packages("qtl2", repos="https://rqtl.org/qtl2cran")

The [qtl2](https://github.com/rqtl/qtl2) package is
inspired by the
[tidyverse package](https://cran.r-project.org/package=tidyverse);
it is basically empty, but when you install it, the
[qtl2geno](https://github.com/rqtl/qtl2geno),
[qtl2scan](https://github.com/rqtl/qtl2scan),
[qtl2plot](https://github.com/rqtl/qtl2plot), and
[qtl2convert](https://github.com/rqtl/qtl2convert) packages, plus a
bunch of dependencies, will be installed.

Alternatively, you can install R/qtl2 from its source on
[GitHub](https://github.com/rqtl). (But note that compiling the C++
code can be rather slow.)

On _Windows_, you'll need [Rtools](https://cran.r-project.org/bin/windows/Rtools/).

On _Mac OS X_, you'll need the
[command-line developer tools](https://mac-how-to.gadgethacks.com/how-to/install-command-line-developer-tools-without-xcode-0168115/),
as well as [gfortran](https://gcc.gnu.org/wiki/GFortranBinaries#MacOS).

You then need to install the
[devtools](https://github.com/hadley/devtools) package, plus a set of
package dependencies: [yaml](https://cran.r-project.org/package=yaml),
[jsonlite](https://cran.r-project.org/package=jsonlite),
[data.table](https://cran.r-project.org/package=data.table),
and [RcppEigen](https://github.com/RcppCore/RcppEigen).
(Additional, secondary dependencies will also be installed.)

    install.packages(c("devtools", "yaml", "jsonlite", "data.table", "RcppEigen"))

Finally, install R/qtl2 using `devtools::install_github()`.

    library(devtools)
    install_github("rqtl/qtl2")


## Data file format

The input data file formats for [R/qtl](https://rqtl.org) cannot
handle complex crosses, and so for R/qtl2, we have defined a new
format for the data files. We'll describe it here briefly; for
details, see the separate
[vignette on the input file format](http://kbroman.org/qtl2/assets/vignettes/input_files.html).

QTL mapping data consists of a set of tables of data: marker
genotypes, phenotypes, marker maps, etc. In the new format, these
different tables are in separate comma-delimited (CSV) files. In each
file, the first column is a set of IDs for the rows, and the first row
is a set of IDs for the columns. For example, the phenotype data file
will have individual IDs in the first column and phenotype names in
the first row.

A few important changes in the tabular data:

- We will use not just the genetic marker map, but also a physical map
  (if available).
- Previously, phenotypes and covariates were combined. In the new
  format, we separate numeric phenotypes from the often
  non-numeric covariates.
- We define a table of &ldquo;phenotype covariates.&rdquo; These are
  [metadata](https://en.wikipedia.org/wiki/Metadata) describing the
  phenotypes. For example, in the case of a phenotype measured over
  time, one column in the phenotype covariate data could be the
  time of measurement. For gene expression data, we would have columns
  representing chromosome and physical position of genes, as well as
  gene IDs.

In addition to the set of CSV files with the primary data, we need a
separate &ldquo;control&rdquo; file with various control parameters
(or metadata), including the names of all of the other data files and
the genotype codes used in the genotype data file. The control file is
in a specific format using either [YAML](http://www.yaml.org) or
[JSON](http://json.org); these are human-readable text files for
representing relatively complex data.

A big advantage of this control file scheme is that it greatly
simplifies the function for reading in the data. That function,
`read_cross2()`, has a _single_ argument: the name (with path) of the
control file. So you can read in data like this:

```{r read_cross2, eval=FALSE}
library(qtl2geno)
grav2 <- read_cross2("~/my_data/grav2.yaml")
```

_Note_: it can sometimes confusing which packages you need to load. If
you install the (largely empty) [qtl2](https://github.com/rqtl/qtl2)
package, you can type just

```{r library_qtl2, eval=FALSE}
library(qtl2)
```

and the three main packages,
[qtl2geno](https://github.com/rqtl/qtl2geno),
[qtl2scan](https://github.com/rqtl/qtl2scan), and
[qtl2plot](https://github.com/rqtl/qtl2plot), will be loaded.

The large number of files is a bit cumbersome, so we've made it
possible to use a
[zip file](https://en.wikipedia.org/wiki/Zip_(file_format)) containing
all of the data files, and to read that zip file directly. There's even a
function for creating the zip file:

```{r create_zip, eval=FALSE}
zip_datafiles("~/my_data/grav2.yaml")
```

This `zip_datafiles()` function will read the control file to identify
all of the relevant data files and then zip them up into a file with
the same name and location, but with the extension `.zip` rather than
`.yaml` or `.json`.

To read the data back in, we use the same `read_cross2()` function,
providing the name (and path) of the zip file rather than the control
file.

```{r read_zip, eval=FALSE}
grav2 <- read_cross2("~/my_data/grav2.zip")
```

This can even be done with remote files.

```{r read_remote_zip, eval=FALSE}
grav2 <- read_cross2("http://kbroman.org/qtl2/assets/sampledata/grav2/grav2.zip")
```

Of course, the other advantage of the zip file is that it is
_compressed_ and so smaller than the combined set of CSV files.

The control file may be confusing for some users. To assist in its
construction, there's a function `write_control_file()` that takes the
large set of control parameters as input and then writes the YAML
control file in the appropriate format.


## Sample data sets

The R/qtl2 web site includes
[sample data files](http://kbroman.org/qtl2/pages/sampledata.html) in
the new format. Zipped versions of these datasets are included with
the [qtl2geno](https://github.com/rqtl/qtl2geno) package and can be
loaded into R using the `read_cross2()` function.

In the [qtl2geno package source](https://github.com/rqtl/qtl2geno),
the sample zip files are located in
[`qtl2geno/inst/extdata`](https://github.com/rqtl/qtl2geno/tree/master/inst/extdata).
In the installed version of the package, they are in
`qtl2geno/extdata`, within whatever directory your R packages were
installed. The R function `system.file()` can be used to construct the
path to these files.

For example, one of the sample data sets concerns a gravitropism
phenotype in a set of Arabidopsis recombinant inbred lines (RIL), from
[Moore et al. (2013) Genetics 195:1077-1086](http://www.genetics.org/content/195/3/1077.abstract).
The data are in `qtl2geno/extdata/grav2.zip`, which can be loaded as
follows:

```{r load_grav2, message=FALSE}
library(qtl2geno)
grav2 <- read_cross2( system.file("extdata", "grav2.zip", package="qtl2geno") )
```

Additional sample data sets, including data on Diversity Outbred (DO)
mice, are available at <https://github.com/rqtl/qtl2data>.


## Calculating genotype probabilities

The first basic task in QTL analysis is to calculate conditional
genotype probabilities, given the observed marker data, at each
putative QTL position. This is accomplished with the `calc_genoprob()`
function in the [qtl2geno](https://github.com/rqtl/qtl2geno)
package. Unlike the corresponding function in
[R/qtl](https://rqtl.org), `calc.genoprob()`, the result is not inserted back into the
input cross object, but is returned as a list of three-dimensional
arrays (one per chromosome). Each 3d array of probabilities is
arranged as individuals &times; genotypes &times; positions.

If we wish to perform QTL calculations at positions between markers
(so called "pseudomarkers"), we first need to insert such positions
into the genetic map with the function `insert_pseudomarkers()`.
Unlike [R/qtl], the map is kept separate from the genotype
probabilities.

We'll use the
[iron dataset](https://github.com/kbroman/qtl2/tree/gh-pages/assets/sampledata/iron)
from
[Grant et al. (2006) Hepatology 44:174-185](https://www.ncbi.nlm.nih.gov/pubmed/16799992)
(an intercross) as an example. We first load the data:

```{r load_data}
library(qtl2geno)
iron <- read_cross2( system.file("extdata", "iron.zip", package="qtl2geno") )
```

(_Note_: you can use `library(qtl2)` to load the
three main packages,
[qtl2geno](https://github.com/rqtl/qtl2geno),
[qtl2scan](https://github.com/rqtl/qtl2scan), and
[qtl2plot](https://github.com/rqtl/qtl2plot), all at once.)

We then use `insert_pseudomarkers()` to insert pseudomarkers into the
genetic map, which we grab from the `iron` object as `iron$gmap`:

```{r insert_pseudomarkers}
map <- insert_pseudomarkers(iron$gmap, step=1)
```

And next we use `calc_genoprob()` to calculate the QTL genotype
probabilities.

```{r calc_genoprob}
pr <- calc_genoprob(iron, map, err=0.002)
```

To speed up the calculations with large datasets on a multi-core
machine, you can use the argument `cores`. With `cores=0`, the number
of available cores will be detected via
`parallel::detectCores()`. Otherwise, specify the number of cores as a
positive integer.

```{r calc_genoprob_multicore, eval=FALSE}
pr <- calc_genoprob(iron, map, err=0.002, cores=4)
```

The genome scan functions (see below) use genotype probabilities as
well as a matrix of phenotypes.
If you wished to perform a genome scan via an additive allele model,
you would first convert the genotype probabilities to allele
probabilities, using the function `genoprob_to_alleleprob()`.

```{r allele_probs}
apr <- genoprob_to_alleleprob(pr)
```


## Calculating a kinship matrix

If you wish to perform a genome scan by a linear mixed model,
accounting for the relationships among individuals (in other words,
including a random polygenic effect), you'll need to calculate a
kinship matrix for the individuals. This is accomplished with the
`calc_kinship()` function in
[qtl2geno](https://github.com/rqtl/qtl2geno).
It takes the genotype probabilities as input.

```{r calc_kinship}
kinship <- calc_kinship(pr)
```

By default, the genotype probabilities are converted to allele
probabilities, and the kinship matrix is calculated as the proportion
of shared alleles. To use genotype probabilities instead, use
`use_allele_probs=FALSE`. Further, by default we omit the
X chromosome and only use the autosomes. To include the X chromosome,
use `omit_x=FALSE`.

In calculating the kinship matrix, one may wish to eliminate the effect of varying marker density across
the genome, and only use the
probabilities along the grid of pseudomarkers (defined by the `step`
argument to `insert_pseudomarkers()`. To do so, we need to first use
`calc_grid()` to determine the grid of pseudomarkers, and then
`probs_to_grid()` to probabilities for positions that are not on the
grid.

```{r calc_kinship_grid}
grid <- calc_grid(iron$gmap, step=1)
pr_grid <- probs_to_grid(pr, grid)
kinship_grid <- calc_kinship(pr_grid)
```

If, for your linear mixed model genome scan, you wish to use the
"leave one chromosome out" (LOCO) method (scan each
chromosome using a kinship matrix that is calculated using data from
all other chromosomes), use `type="loco"` in the call to
`calc_kinship()`.

```{r calc_kinship_loco}
kinship_loco <- calc_kinship(pr, "loco")
```

On a multi-core machine, you can get some speed-up via the `cores`
argument, as with `calc_genoprob()`.

```{r calc_kinship_loco_multicore, eval=FALSE}
kinship_loco <- calc_kinship(pr, "loco", cores=4)
```


## Special covariates for the X chromosome

In a QTL scan of the X chromosome, special covariates (such as sex)
may need to be included under the null hypothesis of no QTL, to avoid
spurious evidence of linkage. (See
[Broman et al. (2006) Genetics 174:2151-2158](http://www.genetics.org/content/174/4/2151.long).)

The particular X chromosome covariates depends on the cross, and can
be obtained with the [qtl2geno](https://github.com/rqtl/qtl2geno)
function `get_x_covar()`.

```{r x_covar}
Xcovar <- get_x_covar(iron)
```


## Performing a genome scan

To perform a genome scan by Haley-Knott regression
([Haley and Knott 1992](https://www.ncbi.nlm.nih.gov/pubmed/16718932)),
use the function `scan1()` in
[qtl2scan](https://github.com/rqtl/qtl2scan). (The functions above
were all from [qtl2geno](https://github.com/rqtl/qtl2geno); from here
forward, the functions are all from
[qtl2scan](https://github.com/rqtl/qtl2scan).)

`scan1()` takes as input the genotype probabilities, a matrix of
phenotypes, and then optional additive and interactive covariates, and
the special X chromosome covariates. Another option is to provide a
vector of weights.

```{r scan1}
library(qtl2scan)
out <- scan1(pr, iron$pheno, Xcovar=Xcovar)
```

On a multi-core machine, you can get some speed-up via the `cores`
argument, as with `calc_genoprob()` and `calc_kinship()`.

```{r scan1_multicore, eval=FALSE}
out <- scan1(pr, iron$pheno, Xcovar=Xcovar, cores=4)
```

The output of `scan1()` is a matrix of LOD scores, positions &times;
phenotypes. (Well, actually, the output is a list including
`"lod"` which is this matrix of LOD scores, but also including the
genetic map and other details.)

The function `plot_scan1()` in the
[qtl2plot](https://github.com/rqtl/qtl2plot) package can be used to
plot the LOD curves. You can just write `plot()`, as there's an S3
method `plot.scan1()` and the output of `scan1()` has class `"scan1"`.
Use the argument `lodcolumn` to indicate which column to plot. Unlike the
`plot.scanone()` function in [R/qtl](https://rqtl.org), the
`plot_scan1()` function will only plot one set of LOD curves at a
time, and you need to provide the marker/pseudomarker map (created by
`insert_pseudomarkers()`).

```{r plot_lod}
library(qtl2plot)
par(mar=c(5.1, 4.1, 1.1, 1.1))
ymx <- maxlod(out) # overall maximum LOD score
plot(out, map, lodcolumn=1, col="slateblue", ylim=c(0, ymx*1.02))
plot(out, map, lodcolumn=2, col="violetred", add=TRUE)
legend("topleft", lwd=2, col=c("slateblue", "violetred"), colnames(out), bg="gray90")
```


## Finding LOD peaks

The function `find_peaks()` in the
[qtl2scan](https://github.com/rqtl/qtl2scan) package can be used to
identify a set of LOD peaks that exceed some threshold. It can also
provide LOD support or Bayes credible intervals, by using the
arguments `drop` (the amount to drop in the LOD support intervals)
or `prob` (the nominal coverage for the Bayes credible intervals).

You need to provide both the `scan1()` output as well as the
marker/pseudomarker map.

```{r find_peaks}
find_peaks(out, map, threshold=4, drop=1.5)
```

The `find_peaks()` function can also pick out multiple peaks on a
chromosome: each peak must exceed the chosen threshold, and the
argument `peakdrop` indicates the amount that the LOD curve must drop
between the lowest of two adjacent peaks.  Use this feature with
caution.

```{r find_multiple_peaks}
find_peaks(out, map, threshold=4, peakdrop=1.8, drop=1.5)
```

The functions `lod_int()` and `bayes_int()` can be used to derive the
LOD support or Bayes credible intervals for QTL, for a specific
chromosome and LOD score column. For example, to obtain the Bayes
interval for the locus on chromosome 9 for the second phenotype
("spleen"):

```{r bayes_int}
bayes_int(out, map, lodcolumn=2, chr=9, prob=0.95)
```

Both `lod_int()` and `bayes_int()` take a `peakdrop` argument, if you
wish to try to identify multiple peaks on a chromosome. Again, use
this feature with caution.

```{r lod_int_multiple}
lod_int(out, map, lodcolumn=1, chr=7, peakdrop=1.8, drop=1.5)
```

Each row is a different peak; the columns are the lower interval endpoint, the
estimated QTL position, and the upper interval endpoint.


## Performing a genome scan with a linear mixed model

To perform a genome scan using a linear mixed model, accounting for
relationships among individuals using a random polygenic effect, you also use
the function `scan1`; you just need to provide the argument `kinship`,
a kinship matrix (or, for the LOCO method, a list of kinship
matrices).

```{r scan1_pg}
out_pg <- scan1(pr, iron$pheno, kinship, Xcovar=Xcovar)
```

Again, on a multi-core machine, you can get some speed-up using the
`cores` argument.

```{r scan1_pg_multicore, eval=FALSE}
out_pg <- scan1(pr, iron$pheno, kinship, Xcovar=Xcovar, cores=4)
```

For the LOCO (leave one chromosome out) method, provide the list of
kinship matrices as obtained from `calc_kinship()` with
`method="loco"`.

```{r scan1_pg_loco}
out_pg_loco <- scan1(pr, iron$pheno, kinship_loco, Xcovar=Xcovar)
```

To plot the results, we again use `plot_scan1()` from the
[qtl2plot](https://github.com/rqtl/qtl2plot) package, or just type `plot()`.

Here is a plot of the LOD scores, by Haley-Knott regression and the linear
mixed model using either the standard kinship matrix or the LOCO
method.

```{r plot_lod_scan1_vs_pg}
color <- c("slateblue", "violetred", "green3")
par(mar=c(4.1, 4.1, 1.6, 1.1))
ymx <- max(maxlod(out), maxlod(out_pg), maxlod(out_pg_loco))
for(i in 1:2) {
    plot(out, map, lodcolumn=i, col=color[1], main=colnames(iron$pheno)[i],
              ylim=c(0, ymx*1.02))
    plot(out_pg, map, lodcolumn=i, col=color[2], add=TRUE)
    plot(out_pg_loco, map, lodcolumn=i, col=color[3], add=TRUE, lty=2)
    legend("topleft", lwd=2, col=color, c("H-K", "LMM", "LOCO"), bg="gray90", lty=c(1,1,2))
}
```

For the liver phenotype (top panel), the three methods give quite
different results. The linear mixed model with an overall kinship
matrix gives much lower LOD scores than the other two methods.  On
chromosomes with some evidence of a QTL, the LOCO method gives higher
LOD scores than Haley-Knott, except on chromosome 16 where it gives
lower LOD scores.

For the spleen phenotype (bottom panel), the linear mixed model with an
overall kinship matrix again gives much lower LOD scores than the
other two methods. However, in this case Haley-Knott regression and
the LOCO method give quite similar results.


## Performing a genome scan with binary traits

The genome scans above were performed assuming that the residual
variation followed a normal distribution. This will often provide
reasonable results even if the residuals are not normal, but an
important special case is that of a binary trait, with values 0 and 1,
which is best treated differently. The `scan1` function can perform a
genome scan with binary traits by logistic regression, using the
argument `model="binary"`. (The default value for the `model` argument
is `"normal"`.) At present, we _can not_ account for relationships
among individuals in this analysis.

Let's first turn our two phenotypes into binary traits by thresholding
at the median. One would generally _not_ do this in practice;
this is just for illustration.

```{r threshold_phenotypes}
bin_pheno <- apply(iron$pheno, 2, function(a) as.numeric(a > median(a)))
rownames(bin_pheno) <- rownames(iron$pheno)
```

We now perform the genome scan as before, including `model="binary"`
to indicates that the phenotypes are binary traits with values 0 and
1.

```{r binary_trait_scan}
out_bin <- scan1(pr, bin_pheno, Xcovar=Xcovar, model="binary")
```

Here is a plot of the two LOD curves.

```{r plot_bin_scan}
par(mar=c(5.1, 4.1, 1.1, 1.1))
ymx <- maxlod(out_bin)
plot(out_bin, map, lodcolumn=1, col="slateblue", ylim=c(0, ymx*1.02))
plot(out_bin, map, lodcolumn=2, col="violetred", add=TRUE)
legend("topleft", lwd=2, col=c("slateblue", "violetred"), colnames(out_bin), bg="gray90")
```

We can use `find_peaks` as before.

```{r find_peaks_bin_scan}
find_peaks(out_bin, map, threshold=3.5, drop=1.5)
```



## Performing a permutation test

To perform a permutation test to establish the statistical significance of
the results of a genome scan, use the function `scan1perm()`. (In
[R/qtl](https://rqtl.org), a single function, `scanone()`, was used for
both performing a genome scan and for getting permutation-based
significance thresholds, but in [R/qtl2](http://kbroman.org/qtl2),
we've decided to make two separate functions).

The `scan1perm()` function takes the same arguments as `scan1()`, plus
additional arguments to control the permutations:

- `n_perm` is the number of permutation replicates.
- `perm_Xsp` controls whether to perform autosome/X chromosome
  specific permutations (with `perm_Xsp=TRUE`) or not (the default is
  to not).
- `perm_strata` is a vector that defines the strata for a stratified permutation
  test.
- `chr_lengths` is a vector of chromosome lengths, used in the case
  that `perm_Xsp=TRUE`.

As with `scan1()`, you may provide a kinship matrix (or vector of
kinship matrices, for the "leave one chromosome out" (loco) approach),
in order to fit linear mixed models to account for accounting for the
relationships among individuals (in other words, including a random
polygenic effect). If `kinship` is unspecified, the function performs
ordinary Haley-Knott regression.

```{r set_seed, echo=FALSE}
set.seed(49237170)
RNGkind("Mersenne-Twister")
```

To perform a permutation test with the `iron` data, we do the following:

```{r scan1perm, eval=FALSE}
operm <- scan1perm(pr, iron$pheno, Xcovar=Xcovar, n_perm=1000)
```

Note the need to specify special covariates for the X chromosome (via
`Xcovar`), to be included under the null hypothesis of no QTL.
And note that when these are provided, the default is to perform a
stratified permutation test, using strata defined by the rows in
`Xcovar`. In general, when the X chromosome is considered, one will
wish to stratify at least by sex.

Also note that, as with `scan1()`, you can speed up the calculations on a multi-core
machine by specifying the argument `cores`. With `cores=0`, the number
of available cores will be detected via `parallel::detectCores()`.
Otherwise, specify the number of cores as a positive integer.
For large datasets, be mindful of the amount of memory that will be
needed; you may need to use fewer than the maximum number of cores,
to avoid going beyond the available memory.

```{r scan1perm_multicore, eval=FALSE}
operm <- scan1perm(pr, iron$pheno, Xcovar=Xcovar, n_perm=1000, cores=0)
```

To get estimated significance thresholds, use the function
`summary()`.

```{r create_summary, echo=FALSE}
# skipped the permutations above and am hard-coding the results here
operm_summary <- structure(c(3.46116054889584, 3.46335159869951), .Dim = 1:2, .Dimnames = list(
                 "0.05", c("liver", "spleen")), class = c("summary.scan1perm",
                 "matrix"), n_perm = structure(c(1000, 1000), .Dim = 1:2, .Dimnames = list(
                 NULL, c("liver", "spleen"))))
```

```{r summary_scan1perm, eval=FALSE}
summary(operm)
```

```{r summary_scan1perm_run, echo=FALSE}
print(operm_summary)
```

The default is to return the 5% significance thresholds. Thresholds for
other (or for multiple) significance levels can be obtained via the
`alpha` argument.

```{r create_summary_B, echo=FALSE}
# skipped the permutations above and am hard-coding the results here
operm_summary_B <- structure(c(2.62593592893683, 3.46116054889584, 2.63661419257339,
                   3.46335159869951), .Dim = c(2L, 2L), .Dimnames = list(c("0.2",
                   "0.05"), c("liver", "spleen")), class = c("summary.scan1perm",
                   "matrix"), n_perm = structure(c(1000, 1000), .Dim = 1:2, .Dimnames = list(
                   NULL, c("liver", "spleen"))))
```

```{r summary_scan1perm_B, eval=FALSE}
summary(operm, alpha=c(0.2, 0.05))
```

```{r summary_scan1perm_B_run, echo=FALSE}
print(operm_summary_B)
```

To obtain autosome/X chromosome-specific significance thresholds,
specify `perm_Xsp=TRUE`. In this case, you need to provide chromosome
lengths, which may be obtained with the function `chr_lengths()`.

```{r set_seed_again, echo=FALSE}
set.seed(49237170)
```

```{r scan1perm_Xsp, eval=FALSE}
operm2 <- scan1perm(pr, iron$pheno, Xcovar=Xcovar, n_perm=1000,
                    perm_Xsp=TRUE, chr_lengths=chr_lengths(map))
```

Separate permutations are performed for the autosomes and X
chromosome, and considerably more permutation replicates are needed
for the X chromosome. The computations take about twice as much time.
See [Broman et al. (2006) Genetics
174:2151-2158](https://www.ncbi.nlm.nih.gov/pubmed/17028340).

The significance thresholds are again derived via `summary()`:

```{r create_summary_C, echo=FALSE}
# skipped the permutations above and am hard-coding the results here
operm2_summary <- structure(list(A = structure(c(2.65418133901934, 3.42486248852004,
                  2.54301332030778, 3.22481615651871), .Dim = c(2L, 2L), .Dimnames = list(
                  c("0.2", "0.05"), c("liver", "spleen"))), X = structure(c(3.09791964868745,
                  3.89645628736863, 4.01757985708749, 5.17928309851641), .Dim = c(2L,
                  2L), .Dimnames = list(c("0.2", "0.05"), c("liver", "spleen")))), .Names = c("A",
                  "X"), class = c("summary.scan1perm", "list"), n_perm = structure(c(1000,
                  28243, 1000, 28243), .Dim = c(2L, 2L), .Dimnames = list(c("A",
                  "X"), c("liver", "spleen"))))
```

```{r summary_scan1perm_C, eval=FALSE}
summary(operm2, alpha=c(0.2, 0.05))
```

```{r summary_scan1perm_C_run, echo=FALSE}
print(operm2_summary)
```

Permutations for a genome scan with a linear mixed model-based are
performed by specifying the `kinship` argument. We can
use the "leave one chromosome out" (loco) method by providing
`kinship_loco`, the list of kinship matrices calculated above with
`calc_kinship()`.

```{r set_seed_yet_again, echo=FALSE}
set.seed(49237170)
```

```{r scan1perm_lmm, eval=FALSE}
operm3 <- scan1perm(pr, iron$pheno, kinship_loco, Xcovar=Xcovar, n_perm=1000,
                    perm_Xsp=TRUE, chr_lengths=chr_lengths(map))
```

Here are the estimated significance thresholds:

```{r create_summary_D, echo=FALSE}
# skipped the permutations above and am hard-coding the results here
operm3_summary <- structure(list(A = structure(c(2.64158056099834, 3.2863616632467,
                  2.62334670551258, 3.28542642483703), .Dim = c(2L, 2L), .Dimnames = list(
                  c("0.2", "0.05"), c("liver", "spleen"))), X = structure(c(3.13853435409231,
                  3.81699660922065, 4.36511444098698, 5.49658348000439), .Dim = c(2L,
                  2L), .Dimnames = list(c("0.2", "0.05"), c("liver", "spleen")))), .Names = c("A",
                  "X"), class = c("summary.scan1perm", "list"), n_perm = structure(c(1000,
                  28243, 1000, 28243), .Dim = c(2L, 2L), .Dimnames = list(c("A",
                  "X"), c("liver", "spleen"))))
```

```{r summary_scan1perm_D, eval=FALSE}
summary(operm3, alpha=c(0.2, 0.05))
```

```{r summary_scan1perm_D_run, echo=FALSE}
print(operm3_summary)
```

As with `scan1`, we can use `scan1perm` with binary traits, using the
argument `model="binary"`. Again, this can't be used with a kinship
matrix, but all of the other arguments can be applied.

```{r scan1perm_binary, eval=FALSE}
operm_bin <- scan1perm(pr, bin_pheno, Xcovar=Xcovar, model="binary",
                       n_perm=1000, perm_Xsp=TRUE, chr_lengths=chr_lengths(map))
```

Here are the estimated 5% and 20% significance thresholds.

```{r scan1perm_binary_summary, echo=FALSE}
operm_bin_summary <- structure(list(A = structure(c(2.59831201609688, 3.32949509346178,
                         2.62913892355286, 3.40933644523101), .Dim = c(2L, 2L), .Dimnames = list(
                         c("0.2", "0.05"), c("liver", "spleen"))), X = structure(c(3.16115845941841,
                         3.85862831021874, 3.0614902104213, 3.76657536814501), .Dim = c(2L,
                         2L), .Dimnames = list(c("0.2", "0.05"), c("liver", "spleen")))), .Names = c("A",
                         "X"), class = c("summary.scan1perm", "list"), n_perm = structure(c(1000,
                         28243, 1000, 28243), .Dim = c(2L, 2L), .Dimnames = list(c("A",
                         "X"), c("liver", "spleen"))))
```

```{r summary_scan1perm_binary, eval=FALSE}
summary(operm_bin, alpha=c(0.2, 0.05))
```

```{r summary_scan1perm_binary_run, echo=FALSE}
print(operm_bin_summary)
```


## Estimated QTL effects

The `scan1()` function return only LOD scores. To
obtain estimated QTL effects, use the function `scan1coef()`.
This function takes a single phenotype and the
genotype probabilities for a single chromosome and returns a matrix
with the estimated coefficients at each putative QTL location along
the chromosome.

For example, to get the estimated effects on chromosome 2 for the
liver phenotype, we'd do the following:

```{r est_effects_liver_c2}
c2eff <- scan1coef(pr[,"2"], iron$pheno[,"liver"])
```

The result is a matrix, `r nrow(c2eff)` positions &times; `r ncol(c2eff)`
genotypes. An attribute, `"map"` contains the positions of the
calculations. To plot the effects, use the function `plot_coef()` from
the [qtl2plot](https://github.com/rqtl/qtl2plot). There is again an S3
method function `plot.scan1coef()`, so one can just type `plot()`.
Use the argument `columns` to indicate which coefficient columns to plot.

```{r plot_effects_liver_c2}
par(mar=c(4.1, 4.1, 1.1, 2.6), las=1)
col <- c("slateblue", "violetred", "green3")
plot(c2eff, map["2"], columns=1:3, col=col)
last_coef <- unclass(c2eff)[nrow(c2eff),] # pull out last coefficients
for(i in seq(along=last_coef))
    axis(side=4, at=last_coef[i], names(last_coef)[i], tick=FALSE, col.axis=col[i])
```

The default is to provide phenotype averages for each genotype
group. If instead you want additive and dominance effects, you can
provide a square matrix of _contrasts_, as follows:

```{r est_effects_liver_c2_contr}
c2effB <- scan1coef(pr[,"2"], iron$pheno[,"liver"],
                    contrasts=cbind(mu=c(1,1,1), a=c(-1, 0, 1), d=c(-0.5, 1, -0.5)))

```

The result will then contain the estimates of `mu`, `a`, and `d`.
Here's a plot of the additive and dominance effects, which are in the
second and third columns.


```{r plot_effects_liver_c2_contr}
par(mar=c(4.1, 4.1, 1.1, 2.6), las=1)
plot(c2effB, map["2"], columns=2:3, col=col)
last_coef <- unclass(c2effB)[nrow(c2effB),2:3] # last two coefficients
for(i in seq(along=last_coef))
    axis(side=4, at=last_coef[i], names(last_coef)[i], tick=FALSE, col.axis=col[i])
```

If you provide a kinship matrix to `scan1coef()`, it fits a linear
mixed model (LMM) to account for a residual polygenic effect. Here
let's use the kinship matrix from the LOCO method.

```{r est_effects_pg_liver_c2}
c2eff_pg <- scan1coef(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]])
```

Here's a plot of the estimates.

```{r plot_effects_pg_liver_c2}
par(mar=c(4.1, 4.1, 1.1, 2.6), las=1)
col <- c("slateblue", "violetred", "green3")
plot(c2eff_pg, map["2"], columns=1:3, col=col, ylab="Phenotype average")
last_coef <- unclass(c2eff_pg)[nrow(c2eff_pg),]
for(i in seq(along=last_coef))
    axis(side=4, at=last_coef[i], names(last_coef)[i], tick=FALSE, col.axis=col[i])
```

You can also get estimated additive and dominance effects, using a
matrix of contrasts.

```{r est_effects_pg_liver_c2_contr}
c2effB_pg <- scan1coef(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]],
                       contrasts=cbind(mu=c(1,1,1), a=c(-1, 0, 1), d=c(-0.5, 1, -0.5)))
```

Here's a plot of the results.

```{r plot_effects_pg_liver_c2_contr}
par(mar=c(4.1, 4.1, 1.1, 2.6), las=1)
plot(c2effB_pg, map["2"], columns=2:3, col=col)
last_coef <- unclass(c2effB_pg)[nrow(c2effB_pg),2:3]
for(i in seq(along=last_coef))
    axis(side=4, at=last_coef[i], names(last_coef)[i], tick=FALSE, col.axis=col[i])
```

Another option for estimating the QTL effects is to treat them as
random effects and calculate Best Linear Unbiased Predictors
(BLUPs). This is particularly valuable for multi-parent populations
such as the Collaborative Cross and Diversity Outbred mice, where the
large number of possible genotypes at a QTL lead to considerable
variability in the effect estimates. To calculate BLUPs, use
`scan1blup()`; it takes the same arguments as `scan1coef()`, including
the option of a kinship matrix to account for a residual polygenic
effect.

```{r scan1blup}
c2blup <- scan1blup(pr[,"2"], iron$pheno[,"liver"], kinship_loco[["2"]])
```

Here is a plot of the BLUPs (as dashed curves) alongside the standard
estimates. Note that

```{r plot_scan1blup}
par(mar=c(4.1, 4.1, 1.1, 2.6), las=1)
col <- c("slateblue", "violetred", "green3")
ylim <- range(c(c2blup, c2eff))+c(-1,1)
plot(c2eff, map["2"], columns=1:3, col=col, ylab="Phenotype average", ylim=ylim,
     xlab="Chr 2 position")
plot(c2blup, map["2"], columns=1:3, col=col, add=TRUE, lty=2)
last_coef <- unclass(c2eff)[nrow(c2eff),]
for(i in seq(along=last_coef))
    axis(side=4, at=last_coef[i], names(last_coef)[i], tick=FALSE, col.axis=col[i])
```

The `scan1coef` function can also provide estimated QTL effects for
binary traits, with `model="binary"`. (However, `scan1blup` has not
yet been implemented for binary traits.)

```{r scan1coef_binary}
c2eff_bin <- scan1coef(pr[,"2"], bin_pheno[,"liver"], model="binary")
```

Here's a plot of the effects. They're a bit tricky to interpret, as
their basically log odds ratios.

```{r plot_effects_binary}
par(mar=c(4.1, 4.1, 1.1, 2.6), las=1)
col <- c("slateblue", "violetred", "green3")
plot(c2eff_bin, map["2"], columns=1:3, col=col)
last_coef <- unclass(c2eff_bin)[nrow(c2eff_bin),] # pull out last coefficients
for(i in seq(along=last_coef))
    axis(side=4, at=last_coef[i], names(last_coef)[i], tick=FALSE, col.axis=col[i])
```




## SNP association

For multi-parent crosses, it can be useful to collapse the genotype or
allele probabilities according to the founder genotypes of the various
SNPs in the region of a QTL.

### QTL analysis in Diversity Outbred mice

To illustrate this sort of SNP association analysis, we'll consider some
Diversity Outbred mouse data. The Diversity Outcross (DO) mice are an
advanced intercross population derived from the same eight founder strains
as the Collaborative Cross (CC). See
[Svenson et al. (2012)](https://www.ncbi.nlm.nih.gov/pubmed/22345611)
and
[Gatti et al. (2014)](https://www.ncbi.nlm.nih.gov/pubmed/25237114).

We'll consider a subset of the data from
[Recla et al. (2014)](https://www.ncbi.nlm.nih.gov/pubmed/24700285),
available as part of the
[qtl2data github repository](https://github.com/rqtl/qtl2data). (The
full data are in
[`DO_Recla`](https://github.com/rqtl/qtl2data/tree/master/DO_Recla);
the directory
[`DOex`](https://github.com/rqtl/qtl2data/tree/master/DOex) contains a
reduced set, with just three chromosomes, one phenotype
(`OF_immobile_pct`, percent immobile in the open field test), and a
reduced set of markers.

You can download the data from a single zip file, as follows:

```{r read_DOex_data}
file <- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex.zip")
DOex <- read_cross2(file)
```

Let's quickly whip through a basic analysis.

We first calculate genotype probabilities and convert them to allele
probabilities. We'll just use marker locations and not insert any
pseudomarkers.

```{r DOex_calc_genoprob, eval=FALSE}
pr <- calc_genoprob(DOex, error_prob=0.002)
apr <- genoprob_to_alleleprob(pr)
```

```{r download_alleleprobs, echo=FALSE, results="hide"}
tmpfile <- tempfile()
file <- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex_alleleprobs.rds")
download.file(file, tmpfile, quiet=TRUE)
apr <- readRDS(tmpfile)
unlink(tmpfile)
```

We calculate kinship matrices (using the "loco" method, though with the
caveat that here we are only considering genotypes on three chromosomes).

```{r DOex_calc_kinship}
k <- calc_kinship(apr, "loco")
```

We create a numeric covariate for sex; be sure to include the individual
IDs as names.

```{r DOex_create_sex_covar}
sex <- (DOex$covar$Sex == "male")*1
names(sex) <- rownames(DOex$covar)
```

We perform a genome scan with a linear mixed model (adjusting for
a residual polygenic effect), with sex as an additive covariate.

```{r DOex_scan1_pg}
out <- scan1(apr, DOex$pheno, k, sex)
```

Here's a plot of the results.

```{r plot_DOex_scan}
par(mar=c(4.1, 4.1, 0.6, 0.6))
plot(out, DOex$gmap)
```

There's a strong peak on chromosome 2. Let's look at the QTL effects.
We estimate them with `scan1coef()`. We need to subset the allele
probabilities and the list of kinship matrices.

```{r DOex_effects_c2}
coef_c2 <- scan1coef(apr[,"2"], DOex$pheno, k[["2"]], sex)
```

For the DO, with 8 QTL alleles, we can use the function `plot_coefCC`
in the [R/qtl2plot](https://github.com/rqtl/qtl2plot) package, which
plots the 8 allele effects in the "official" Collaborative Cross (CC)
colors. (Well, actually _slightly_ modified colors, because I think the
official colors are kind of ugly.) The strong locus seems to be mostly
due to the NZO allele. Note that `CCcolors` is a vector of colors
included in the qtl2plot package; there's also a `CCorigcolors` object
with the _official_ colors.

```{r plot_DOex_effects}
par(mar=c(4.1, 4.1, 0.6, 0.6))
plot_coefCC(coef_c2, DOex$gmap["2"], bgcolor="gray95")
legend("bottomleft", col=CCcolors, names(CCcolors), ncol=2, lwd=2, bg="gray95")
```

### SNP associations

Okay, now finally we get to the SNP associations. We have a large peak
on chromosome 2, and we want to look at individual SNPs in the region
of the locus.

Well, actually, we first need to find the location of the inferred
QTL.  The peak LOD score on chromosome 2 occurs at
`r round(max(out, DOex$gmap, chr="2")$pos, 1)` cM. But to find nearby SNPs, we really want
to know the Mbp position. The calculations were only performed at the
marker positions, and so we need to find the peak marker and then
find it's physical location:

```{r DOex_find_peak_in_Mbp}
marker <- rownames(max(out, DOex$gmap, chr="2"))
peak_Mbp <- DOex$pmap[["2"]][marker]
```

The marker is at `r round(peak_Mbp, 1)` Mbp.

Now we need to identify the SNPs in this region. We'll focus on a 2
Mbp interval centered at `r round(peak_Mbp, 1)` Mbp. We're still
working on how best to quickly access SNP data. In the meantime, we
can grab a predefined table of SNPs that's available in the
[qtl2data repository](https://github.com/rqtl/qtl2data). It's saved as
an RDS file, which is a slight hassle to load over the web.

```{r load_c2_snps}
tmpfile <- tempfile()
file <- "https://raw.githubusercontent.com/rqtl/qtl2data/master/DOex/c2_snpinfo.rds"
download.file(file, tmpfile, quiet=TRUE)
snpinfo <- readRDS(tmpfile)
unlink(tmpfile)
```

Here's the first few rows of the data. The columns are the SNP name,
the chromosome, the Mbp position (in Mouse genome build 38), the
alleles (with the B6 allele before the `|` and any other alleles
after; in the case of multiple alternate alleles, they are separated
by `/`). Finally, there are eight columns of genotypes for the 8 CC
founder strains, coded as `1`/`3`.

```{r head_snpinfo}
head(snpinfo)
```

We first convert the founder genotypes to a "strain distribution
pattern" (SDP): an integer whose binary encoding corresponds to the 8
founders' genotypes.

```{r calc_sdp}
snpinfo$sdp <- calc_sdp(snpinfo[,-(1:4)])
```

We've added the SDP as an additional column.

```{r head_snpinfo_with_sdp}
head(snpinfo)
```

(Note that there's also a function `invert_sdp()` for converting the
SDPs back into founder genotypes.)

To perform the SNP association analysis, we first use the allele
probabilities and the founder SNP genotypes to infer the SNP genotypes
for the DO mice. That is, at each SNP, we want to collapse the eight
founder allele probabilities to two SNP allele probabilities, using
the the SNP genotypes of the founders.

We do this assuming that the allele probabilities were
calculated sufficiently densely that they can be assumed to be
constant in intervals. With this assumption, we then:

- Find the interval for each SNP.
- Reduce the SNPs to a "distinct" set: if two SNPs have the same SDP
  and are in the same interval, by our assumption their allele
  probabilities will be the same.
- Take the average of the allele probabilities at the two endpoints of
  each interval.
- Collapse the 8 allele probabilities to two according to each
  observed SDP in the interval.

We further create a look-up table relating the full set of SNPs to the
reduced set (one of each observed SDP in each interval).

We first need to identify the equivalent SNPs, using the function
`index_snps()`. This requires a physical map of the
markers/pseudomarkers used to calculate the genotype probabilities.
We take this directly from the `DOex`
object, as we'd calculated the allele
probabilities only at the observed markers. If we'd also calculated
probabilities at pseudomarker positions between markers, we'd need to
use interpolation to get Mbp positions for the
pseudomarkers. There's a function `interp_map()` for assisting with
that.

The `index_snps()` function takes the physical map and the `snpinfo`
data frame, include the strain distribution patterns we calculated above.
It inserts three new columns into the data frame (`"index"`,
`"interval"`, and `"on_map"`: indexes to a set of non-equivalent SNPs,
map intervals in which the SNPs lie, and whether the SNPs correspond
to marker/pseudomarker positions).

```{r index_snps}
snpinfo <- index_snps(DOex$pmap, snpinfo)
```

We can then use the function `genoprob_to_snpprob()`,
which takes the allele probabilities (or the full genotype
probabilities, if you want to use a full 3-genotype model at each
SNP), to collapse the genotype probabilities to SNP genotype
probabilities.

```{r calc_snpprobs}
snp_pr <- genoprob_to_snpprob(apr, snpinfo)
```

The output of this function, `snp_pr`, has the same form as the input
`apr` object with allele probabilities, and can be used directly in a
call to `scan1()`. And so we can now use the object to perform the SNP
association analysis in the region, using the same linear mixed model.
We need to be sure to use the correct kinship matrix.

```{r perform_snp_scan}
out_snps <- scan1(snp_pr, DOex$pheno, k[["2"]], sex)
```

The function `plot_snpasso()` in the qtl2plot package can be used to
plot the results, with points at each of the SNPs. The default is to
plot **all** SNPs: We calculated LOD scores only at a set of distinct
SNPs, but SNPs in the same interval with the same SDP will have the
same LOD score. It takes the `scan1()` output plus the `snpinfo` data
frame.

```{r plot_snp_asso}
par(mar=c(4.1, 4.1, 0.6, 0.6))
plot_snpasso(out_snps, snpinfo)
```

To get a table of the SNPs with the largest LOD scores, use the
function `top_snps()`. This will show all SNPs with LOD score within
some amount (the default is 1.5) of the maximum SNP LOD score.

```{r top_snps}
top_snps(out_snps, snpinfo)
```

The top SNPs all have NZO and CAST with a common allele, different
from the other 6 founders. The next-best SNPs have NZO with a unique
allele. Note that there's one SNP with two alternate alleles
(`C|G/T`). We are requiring that SNPs have just two alleles, and so we
group the alternate alleles together, though there's not a good reason
for this.

We can highlight these top SNPs in the SNP association plot using the
`drop` argument.

```{r plot_snp_asso_hilit}
par(mar=c(4.1, 4.1, 0.6, 0.6))
plot_snpasso(out_snps, snpinfo, drop=1.5)
```
